<template id="template-zombie-game">
  <style>
    #arena { position: relative; height: clamp(180px, 36vh, 320px); margin-top: 10px; background: linear-gradient(#f0f9ff, #e0f2fe); border-radius: 12px; overflow: hidden; box-shadow: inset 0 -6px 0 #cbd5e1; }
    #hero, #zombie, #projectile { position: absolute; bottom: 0; height: clamp(90px, 26vh, 200px); max-width: 32vw; object-fit: contain; user-select: none; pointer-events: none; }
    #hero { left: min(3vw, 24px); }
    #zombie { right: min(3vw, 24px); transition: right 0.08s linear; }
    #projectile { width: clamp(18px, 3vh, 28px); height: clamp(18px, 3vh, 28px); background: radial-gradient(circle, #38bdf8 0%, #0284c7 80%); border-radius: 50%; display: none; bottom: calc(clamp(90px, 26vh, 200px) * 0.55); z-index: 10; }
    
    .question-zone { margin-bottom: 10px; font-size: 1.3em; text-align: center; min-height: 2em; color: #334155; font-weight: 600; margin-top: 15px; }

    #ai-input-zone { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; max-width: 600px; margin: 0 auto; position: relative; }
    
    /* Zone r√©ponse avec Micro */
    .input-wrapper {
      display: flex; width: 100%; gap: 8px;
    }
    
    textarea#answer {
      flex: 1; padding: 12px; font-size: 16px; border-radius: 10px;
      border: 2px solid #cbd5e1; resize: none; height: 80px; font-family: inherit;
    }
    
    /* Bouton Micro */
    #btn-mic {
      width: 80px; border-radius: 10px; border: 2px solid #cbd5e1;
      background: white; font-size: 30px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: 0.2s;
    }
    #btn-mic.recording {
      background: #fee2e2; border-color: #ef4444;
      animation: pulse 1s infinite;
    }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

    .buttons-row { display: flex; gap: 10px; width: 100%; justify-content: center; }
    button { padding: 10px 20px; border: 0; border-radius: 8px; font-size: 15px; cursor: pointer; font-weight: 600; transition: 0.2s; }
    #submit { background: #2563eb; color: #fff; flex: 1; }
    #submit:disabled { background: #94a3b8; cursor: not-allowed; }
    #giveup { background: #fef2f2; color: #dc2626; border: 2px solid #fca5a5; flex: 1; }
    
    #bravo-badge {
      position: absolute; top: 10px; right: 10px; background: #2563eb; color: white;
      padding: 10px 16px; border-radius: 12px; font-weight: bold; font-size: 14px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); display: none; animation: popIn 0.3s ease-out;
      z-index: 50; max-width: 280px; text-align: left;
    }
    .spelling-list { margin: 6px 0 0; padding-left: 0; list-style: none; font-size: 0.9em; }
    .spelling-item { display: block; margin-bottom: 2px; }
    .wrong-word { color: #fecaca; text-decoration: line-through; font-weight: 700; margin-right: 4px; }
    .right-word { color: #bbf7d0; font-weight: 700; }
    
    #analysis-msg { display: none; color: #2563eb; font-weight: bold; margin-top: 5px; }
    @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    .choices-zone, #freeInputZone { display: none !important; }
  </style>
  
  <div id="arena"> 
    <img id="hero" src="images/hero.png" alt="H√©ros" /> <img id="zombie" src="images/zombi.png" alt="Zombie" /> <div id="projectile"></div> <div id="bravo-badge">üéâ Bravo !</div>
  </div>

  <div id="question" class="question-zone"></div>
  
  <div id="ai-input-zone">
    <div class="input-wrapper">
      <textarea id="answer" placeholder="√âcris ou enregistre ta r√©ponse..." autocomplete="off"></textarea>
      <button id="btn-mic" title="Maintenir pour parler">üéôÔ∏è</button>
    </div>

    <div class="buttons-row">
      <button id="submit">Envoyer</button>
      <button id="giveup">Je ne sais pas</button>
    </div>
    
    <div id="analysis-msg"></div>
  </div>
</template>

<script>
class ZombieGame {
  constructor(c, ctrl) {
    this.c = c; this.ctrl = ctrl;
    this.hero = c.querySelector("#hero"); this.zombie = c.querySelector("#zombie");
    this.projectile = c.querySelector("#projectile"); this.arena = c.querySelector("#arena");
    this.qEl = c.querySelector("#question");
    
    this.input = c.querySelector("#answer");
    this.subBtn = c.querySelector("#submit");
    this.giveUpBtn = c.querySelector("#giveup");
    this.micBtn = c.querySelector("#btn-mic");
    
    this.bravoBadge = c.querySelector("#bravo-badge");
    this.analysisMsg = c.querySelector("#analysis-msg");

    this.zInt = null; this.pInt = null; this.zPos = 20; this.zPaused = false; this.resetting = false;
    
    // Events Texte
    this.subBtn.onclick = () => this.askAI();
    this.giveUpBtn.onclick = () => this.processIncorrect();
    this.input.onkeydown = (e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.askAI(); } };
    this.input.addEventListener("input", () => { this.zPaused = (this.input.value.length > 0); });

    // Events Audio
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.micBtn.addEventListener("mousedown", () => this.startRecording());
    this.micBtn.addEventListener("mouseup", () => this.stopRecording());
    this.micBtn.addEventListener("touchstart", (e) => { e.preventDefault(); this.startRecording(); });
    this.micBtn.addEventListener("touchend", (e) => { e.preventDefault(); this.stopRecording(); });
  }

  loadQuestion(q) {
    this.resetting = false; this.qEl.textContent = q.q; 
    this.input.value = ""; this.input.disabled = false;
    this.subBtn.disabled = false; this.subBtn.textContent = "Envoyer";
    this.bravoBadge.style.display = "none"; this.analysisMsg.style.display = "none";
    
    const max = this.arena.offsetWidth - this.zombie.offsetWidth - this.hero.offsetWidth - 30;
    if (this.zPos >= max) { this.zPos = 20; this.zombie.style.right = "20px"; }
    this.zombie.style.display = "block"; this.zPaused = false; 
    setTimeout(() => this.input.focus(), 100);
  }

  async startRecording() {
    if (!navigator.mediaDevices) { alert("Micro non support√©."); return; }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(stream);
      this.audioChunks = [];
      
      this.mediaRecorder.ondataavailable = (e) => this.audioChunks.push(e.data);
      
      this.mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
        this.sendAudio(audioBlob);
      };

      this.mediaRecorder.start();
      this.micBtn.classList.add("recording");
      this.zPaused = true; // Pause pendant qu'on parle
    } catch (err) { console.error("Erreur micro", err); }
  }

  stopRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.stop();
      this.micBtn.classList.remove("recording");
    }
  }

  async sendAudio(blob) {
    this.analysisMsg.textContent = "üéß Envoi audio...";
    this.analysisMsg.style.display = "block";
    this.input.disabled = true; this.subBtn.disabled = true;

    const currentQ = (typeof levels !== 'undefined') ? levels[currentLevel].questions[currentIndex] : null;
    if(!currentQ) return;

    const formData = new FormData();
    formData.append("audio", blob, "voice.webm");
    formData.append("question", currentQ.q);
    formData.append("expectedAnswer", currentQ.a);

    try {
      const res = await fetch('/api/verify-audio', { method: 'POST', body: formData });
      const data = await res.json();
      this.handleResponse(data);
      
      // On remplit la zone de texte avec ce que l'IA a entendu
      if (data.transcript) this.input.value = data.transcript;

    } catch (e) {
      console.error(e);
      this.analysisMsg.textContent = "Erreur Audio.";
      this.input.disabled = false; this.subBtn.disabled = false;
    }
  }

  async askAI() {
    if(this.ctrl.getState().isLocked || this.input.value.trim() === "") return;
    this.zPaused = true; this.input.disabled = true; this.subBtn.disabled = true;
    this.analysisMsg.textContent = "üß† Analyse..."; this.analysisMsg.style.display = "block";

    const currentQ = (typeof levels !== 'undefined') ? levels[currentLevel].questions[currentIndex] : null;
    try {
      const res = await fetch('/api/verify-answer-ai', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question: currentQ.q, userAnswer: this.input.value, expectedAnswer: currentQ.a })
      });
      const data = await res.json();
      this.handleResponse(data);
    } catch (err) { console.error(err); this.input.disabled = false; this.subBtn.disabled = false; }
  }

  handleResponse(data) {
    this.analysisMsg.style.display = "none"; 
    const status = data.status || (data.correct ? "correct" : "incorrect");
    const corrections = Array.isArray(data.corrections) ? data.corrections : [];

    if (status === "correct") {
      let html = `<div>üéâ ${data.feedback || "Bravo !"}</div>`;
      if (corrections.length > 0) {
        html += `<ul class="spelling-list">`;
        corrections.forEach(c => html += `<li class="spelling-item"><span class="wrong-word">${c.wrong}</span> ‚Üí <span class="right-word">${c.correct}</span></li>`);
        html += `</ul>`;
      }
      this.bravoBadge.innerHTML = html;
      this.bravoBadge.style.display = "block"; 
      this.win(); 
      setTimeout(() => { this.ctrl.notifyCorrectAnswer(); }, 3500);
    } else if (status === "imprecise") {
      this.input.disabled = false; this.subBtn.disabled = false; this.subBtn.textContent = "R√©essayer";
      this.input.focus(); this.zPaused = true;
      this.analysisMsg.textContent = "üí° " + (data.feedback || "Pr√©cise...");
      this.analysisMsg.style.display = "block";
    } else {
      this.processIncorrect();
    }
  }

  processIncorrect() {
    const currentQ = (typeof levels !== 'undefined') ? levels[currentLevel].questions[currentIndex] : null;
    if(typeof localScores !== 'undefined') localScores[currentIndex] = Math.max(0, localScores[currentIndex] - 1);
    if(typeof updateBars !== 'undefined') updateBars();
    this.ctrl.notifyWrongAnswer({ a: currentQ.a });
  }

  startAnimation(){ this.moveZ(); } 
  resetAnimation(){ this.stop(); }
  
  moveZ() {
    if(this.zInt) return;
    this.zombie.style.display="block"; this.zombie.style.opacity="1";
    const max = this.arena.offsetWidth - this.zombie.offsetWidth - this.hero.offsetWidth - 30;
    const step = max / 50000; 
    this.zInt = setInterval(() => {
      if(this.resetting || this.ctrl.getState().isLocked || this.zPaused) return;
      this.zPos += step * 20; this.zombie.style.right = this.zPos + "px";
      if(this.zPos >= max) { this.ctrl.notifyWrongAnswer(null); }
    }, 20);
  }

  stop() {
    this.resetting = true;
    if(this.zInt) { clearInterval(this.zInt); this.zInt = null; }
    if(this.pInt) { clearInterval(this.pInt); this.pInt = null; }
    this.zPaused = false;
    if(this.zombie) { this.zombie.style.display = "block"; this.zombie.style.opacity = "1"; }
    if(this.projectile) { this.projectile.style.display = "none"; }
    if(this.input) { this.input.disabled = false; this.input.value = ""; }
    if(this.subBtn) { this.subBtn.disabled = false; this.subBtn.textContent = "Envoyer"; }
    this.bravoBadge.style.display = "none"; this.analysisMsg.style.display = "none";
  }
  win() { this.shoot(); }
  shoot() {
    if(this.pInt) return;
    this.projectile.style.display = "block";
    let p = this.hero.offsetWidth;
    const hit = this.arena.offsetWidth - parseFloat(this.zombie.style.right||20) - (this.zombie.offsetWidth / 2);
    this.pInt = setInterval(() => {
      if(this.resetting) { clearInterval(this.pInt); this.pInt = null; return; }
      p += 25; this.projectile.style.left = p + "px";
      if(p >= hit) {
        clearInterval(this.pInt); this.pInt = null;
        this.projectile.style.display = "none"; 
        if(!this.resetting) this.zombie.style.display = "none";
      }
    }, 20);
  }
}
window.ZombieGame = ZombieGame;
</script>