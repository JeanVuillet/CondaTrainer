<template id="template-zombie-game">
  <style>
    /* ... (Styles identiques pour l'arÃ¨ne) ... */
    #arena { 
      position: relative; height: clamp(180px, 36vh, 320px); margin-top: 10px; 
      background: linear-gradient(#f0f9ff, #e0f2fe); border-radius: 12px; 
      overflow: hidden; box-shadow: inset 0 -6px 0 #cbd5e1; 
    }
    #hero, #zombie, #projectile { 
      position: absolute; bottom: 0; height: clamp(90px, 26vh, 200px); 
      max-width: 32vw; object-fit: contain; pointer-events: none; 
    }
    #hero { left: min(3vw, 24px); }
    #zombie { right: min(3vw, 24px); transition: right 0.08s linear; }
    #projectile { 
      width: 20px; height: 20px; background: radial-gradient(circle, #38bdf8 0%, #0284c7 80%); 
      border-radius: 50%; display: none; bottom: 100px; z-index: 10; 
    }
    
    .question-zone { 
      margin: 15px 0; font-size: 1.3em; text-align: center; color: #334155; font-weight: 600; 
    }

    /* ZONE IA (CachÃ©e par dÃ©faut) */
    #ai-input-zone { 
      display: none; flex-direction: column; align-items: center; gap: 10px; 
      width: 100%; max-width: 600px; margin: 0 auto; 
    }
    textarea#answer {
      width: 100%; padding: 12px; font-size: 16px; border-radius: 10px;
      border: 2px solid #cbd5e1; resize: none; height: 80px; 
    }
    button#submit { 
      padding: 10px 20px; border: 0; border-radius: 8px; background: #2563eb; 
      color: #fff; font-weight: 600; cursor: pointer; 
    }

    /* ZONE QCM (CachÃ©e par dÃ©faut) */
    #options-grid {
      display: none; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
    }
    .option-btn {
      padding: 15px; font-size: 16px; background: white; border: 2px solid #e2e8f0;
      border-radius: 10px; cursor: pointer; color: #1e293b; font-weight: 600;
      transition: all 0.2s;
    }
    .option-btn:hover { background: #f1f5f9; border-color: #cbd5e1; }
    .opt-correct { background: #dcfce7 !important; border-color: #22c55e !important; color: #166534; }
    .opt-wrong { background: #fee2e2 !important; border-color: #ef4444 !important; color: #991b1b; }

    /* Feedback */
    #feedback-bubble {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      width: 80%; padding: 10px; border-radius: 10px; background: rgba(255,255,255,0.95);
      text-align: center; display: none; z-index: 20; border: 2px solid transparent;
    }
    .fb-success { border-color:#22c55e; color:#166534; }
    .fb-error { border-color:#ef4444; color:#991b1b; }
    .fb-hint { border-color:#f59e0b; color:#92400e; }
  </style>
  
  <div id="arena"> 
    <img id="hero" src="images/hero.png" alt="HÃ©ros" /> 
    <img id="zombie" src="images/zombi.png" alt="Zombie" /> 
    <div id="projectile"></div> 
    <div id="feedback-bubble"></div>
  </div>

  <div id="question" class="question-zone"></div>
  
  <!-- MODE 1 : IA -->
  <div id="ai-input-zone">
    <textarea id="answer" placeholder="Ã‰cris ta rÃ©ponse..." autocomplete="off"></textarea>
    <div class="buttons-row"><button id="submit">Envoyer Ã  l'IA ðŸ¤–</button></div>
  </div>

  <!-- MODE 2 : QCM -->
  <div id="options-grid">
    <button class="option-btn"></button>
    <button class="option-btn"></button>
    <button class="option-btn"></button>
    <button class="option-btn"></button>
  </div>
</template>

<script>
class ZombieGame {
  constructor(c, ctrl) {
    this.c = c; this.ctrl = ctrl;
    // Elements visuels
    this.hero = c.querySelector("#hero"); 
    this.zombie = c.querySelector("#zombie");
    this.projectile = c.querySelector("#projectile"); 
    this.arena = c.querySelector("#arena");
    this.qEl = c.querySelector("#question");
    this.fbBubble = c.querySelector("#feedback-bubble");
    
    // Mode IA
    this.aiZone = c.querySelector("#ai-input-zone");
    this.input = c.querySelector("#answer");
    this.subBtn = c.querySelector("#submit");
    
    // Mode QCM
    this.qcmZone = c.querySelector("#options-grid");
    this.optBtns = c.querySelectorAll(".option-btn");

    this.zInt = null; this.pInt = null; this.zPos = 20; 
    this.zPaused = false; this.resetting = false;
    
    // Events IA
    this.subBtn.onclick = () => this.askAI();
    this.input.onkeydown = (e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.askAI(); } };
    this.input.addEventListener("input", () => { this.zPaused = (this.input.value.length > 0); });

    // Events QCM
    this.optBtns.forEach((btn, idx) => {
        btn.onclick = () => this.checkOption(idx);
    });
  }

  loadQuestion(q) {
    this.currentQ = q;
    this.resetting = false; 
    this.qEl.textContent = q.q; 
    this.fbBubble.style.display = "none";
    this.zPos = 20; 
    this.zombie.style.right = "20px"; 
    this.zombie.style.display = "block"; 
    this.zombie.style.opacity = "1";
    this.zPaused = false; 

    // LOGIQUE DE BASCULE : QCM ou IA ?
    if (q.options && q.options.length > 0) {
        // MODE QCM
        this.aiZone.style.display = "none";
        this.qcmZone.style.display = "grid";
        this.optBtns.forEach((btn, i) => {
            btn.textContent = q.options[i];
            btn.className = "option-btn"; // Reset style
            btn.disabled = false;
        });
    } else {
        // MODE IA
        this.qcmZone.style.display = "none";
        this.aiZone.style.display = "flex";
        this.input.value = ""; 
        this.input.disabled = false;
        this.subBtn.disabled = false;
        this.subBtn.textContent = "Envoyer Ã  l'IA ðŸ¤–";
        setTimeout(() => { if(!window.isGlobalPaused) this.input.focus(); }, 100);
    }
  }

  // --- LOGIQUE QCM ---
  checkOption(idx) {
    if (this.ctrl.getState().isLocked || window.isGlobalPaused) return;
    
    const selected = this.currentQ.options[idx];
    const correct = this.currentQ.a; // RÃ©ponse attendue (string) ou index

    // VÃ©rification souple (si 'a' est l'index ou le texte)
    let isCorrect = false;
    if (typeof correct === 'number') isCorrect = (idx === correct);
    else isCorrect = (selected === correct);

    if (isCorrect) {
        this.optBtns[idx].classList.add("opt-correct");
        this.win();
        setTimeout(() => this.ctrl.notifyCorrectAnswer(), 1000);
    } else {
        this.optBtns[idx].classList.add("opt-wrong");
        this.ctrl.notifyWrongAnswer(null);
    }
  }

  // --- LOGIQUE IA ---
  async askAI() {
    if(window.isGlobalPaused || this.ctrl.getState().isLocked || this.input.value.trim() === "") return;
    
    this.zPaused = true; 
    this.input.disabled = true; this.subBtn.disabled = true;
    this.showFeedback("ðŸ§  Analyse...", "loading");

    const player = JSON.parse(localStorage.getItem('player') || '{}');

    try {
      const res = await fetch('/api/verify-answer-ai', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            question: this.currentQ.q, 
            userAnswer: this.input.value, 
            expectedAnswer: this.currentQ.a,
            playerId: player.id || player._id
        })
      });
      const data = await res.json();
      this.handleResponse(data);
    } catch (err) { 
      this.input.disabled = false; this.subBtn.disabled = false; 
      this.showFeedback("Erreur connexion.", "error");
    }
  }

  handleResponse(data) {
    const status = data.status || (data.correct ? "correct" : "incorrect");
    let correctionsHTML = "";
    if (data.corrections && data.corrections.length > 0) {
      correctionsHTML += `<ul class="spelling-list">`;
      data.corrections.forEach(c => correctionsHTML += `<li class="spelling-item"><span class="wrong-word">${c.wrong}</span> <span class="right-word">${c.correct}</span></li>`);
      correctionsHTML += `</ul>`;
    }

    if (status === "correct") {
      this.showFeedback(`<strong>ðŸŽ‰ ${data.feedback || "Bravo !"}</strong>` + correctionsHTML, "success", true);
      this.win(); 
      setTimeout(() => this.ctrl.notifyCorrectAnswer(), 3000);
    } else if (status === "close") {
      this.showFeedback(`ðŸ’¡ <strong>Indice :</strong> ${data.feedback}` + correctionsHTML, "hint", true);
      setTimeout(() => {
          if(!window.isGlobalPaused) { this.input.disabled = false; this.subBtn.disabled = false; this.input.focus(); }
      }, 3000);
    } else {
      this.showFeedback(`âŒ ${data.feedback || "Incorrect."}`, "error");
      this.ctrl.notifyWrongAnswer(null); // Perte de vie immÃ©diate ici pour le zombie
      setTimeout(() => {
          this.zPaused = false; 
          if(!window.isGlobalPaused) { this.input.disabled = false; this.subBtn.disabled = false; this.input.focus(); }
          this.fbBubble.style.display = "none";
      }, 2500);
    }
  }

  showFeedback(msg, type, isHtml = false) {
    if(!this.fbBubble) return;
    this.fbBubble.className = ""; this.fbBubble.classList.add(`fb-${type}`);
    if(isHtml) this.fbBubble.innerHTML = msg; else this.fbBubble.textContent = msg;
    this.fbBubble.style.display = "block";
  }

  startAnimation(){ this.moveZ(); } 
  resetAnimation(){ this.stop(); }
  moveZ() {
    if(this.zInt) return;
    this.zombie.style.display="block"; this.zombie.style.opacity="1";
    const max = this.arena.offsetWidth - this.zombie.offsetWidth - this.hero.offsetWidth - 30;
    const step = max / 50000; 
    this.zInt = setInterval(() => {
      if(window.isGlobalPaused || this.resetting || this.ctrl.getState().isLocked || this.zPaused) return;
      this.zPos += step * 20; this.zombie.style.right = this.zPos + "px";
      if(this.zPos >= max) { this.ctrl.notifyWrongAnswer(null); }
    }, 20);
  }
  stop() {
    this.resetting = true;
    if(this.zInt) { clearInterval(this.zInt); this.zInt = null; }
    if(this.pInt) { clearInterval(this.pInt); this.pInt = null; }
    this.zPos = 20; this.zPaused = false;
    this.zombie.style.right = "20px"; this.zombie.style.display = "block";
    this.projectile.style.display = "none"; this.projectile.style.left = "0px";
    this.aiZone.style.display = "none"; // Reset UI
    this.qcmZone.style.display = "none";
    this.fbBubble.style.display = "none";
  }
  win() { this.shoot(); }
  shoot() {
    if(this.pInt) return;
    this.projectile.style.display = "block";
    let p = this.hero.offsetWidth;
    const zRight = parseFloat(this.zombie.style.right) || 20;
    const hit = this.arena.offsetWidth - zRight - (this.zombie.offsetWidth / 2);
    this.pInt = setInterval(() => {
      if(this.resetting) { clearInterval(this.pInt); this.pInt = null; return; }
      p += 25; this.projectile.style.left = p + "px";
      if(p >= hit) {
        clearInterval(this.pInt); this.pInt = null;
        this.projectile.style.display = "none"; this.projectile.style.left = "0px";
        if(!this.resetting) this.zombie.style.display = "none";
      }
    }, 20);
  }
}
window.ZombieGame = ZombieGame;
</script>