<template id="template-starship-game">
  <style>
    #starshipGame {
      position: relative;
      width: 100%;
      height: 450px;
      background: #0c0a18;
      overflow: hidden;
      cursor: crosshair;
    }
    #ship {
      position: absolute;
      bottom: 10px;
      left: 50%;
      width: 60px;
      height: 60px;
      transform: translateX(-50%);
      background: url('/images/ship.png') center/contain no-repeat;
      transition: left 0.1s linear;
    }
    .falling-answer {
      position: absolute;
      top: -60px;
      padding: 10px 20px;
      background: #333;
      color: white;
      border: 2px solid #00f2ff;
      border-radius: 8px;
      animation: fall 10s linear forwards;
      font-weight: bold;
    }
    @keyframes fall {
      from { top: -60px; }
      to { top: 500px; transform: rotate(360deg); }
    }
    .bullet {
      position: absolute;
      width: 8px;
      height: 25px;
      background-color: #ffeb3b;
      border-radius: 4px;
      box-shadow: 0 0 10px #ffeb3b;
    }
  </style>
  <div id="question" class="question-zone" style="margin-bottom: 8px;"></div>
  <div id="starshipGame">
    <div id="ship"></div>
  </div>
  <!-- Ces divs sont là pour la compatibilité mais ne sont pas utilisées par ce jeu -->
  <div id="choices" style="display:none;"></div>
  <div id="freeInputZone" style="display:none;"></div>
</template>

<script>
class StarshipGame {
  constructor(container, controller) {
    this.container = container;
    this.controller = controller;
    this.gameArea = container.querySelector("#starshipGame");
    this.ship = container.querySelector("#ship");
    this.answers = [];
    this.bullets = [];
    this.animationFrameId = null;

    // Propriétés pour la question actuelle
    this.currentQuestion = null;
    this.currentCorrectAnswer = '';
    this.currentAnswers = [];

    this.bindControls();
  }
  
  // Méthode pour recevoir les données de la question de main.js
  loadQuestion(q) {
    this.currentQuestion = q;
    this.currentCorrectAnswer = q.a;
    this.currentAnswers = [...q.options];
    this.spawnAnswers();
  }

  resetAnimation() {
    this.clearObjects();
    cancelAnimationFrame(this.animationFrameId);
  }

  startAnimation() {
    this.loop();
  }

  bindControls() {
    document.addEventListener("keydown", (e) => {
      if (this.controller.getState().isLocked) return;
      if (e.key === "ArrowLeft") this.moveShip(-40);
      if (e.key === "ArrowRight") this.moveShip(40);
      if (e.code === "Space") {
        e.preventDefault();
        this.shoot();
      }
    });
  }

  moveShip(dx) {
    const x = this.ship.offsetLeft + dx;
    const maxX = this.gameArea.offsetWidth - this.ship.offsetWidth;
    this.ship.style.left = Math.min(maxX, Math.max(0, x)) + "px";
  }

  shoot() {
    const bullet = document.createElement("div");
    bullet.className = "bullet";
    bullet.style.left = this.ship.offsetLeft + this.ship.offsetWidth / 2 - 4 + "px";
    bullet.style.bottom = "70px";
    this.gameArea.appendChild(bullet);
    this.bullets.push(bullet);
  }

  spawnAnswers() {
    this.clearObjects();
    let positions = [10, 25, 40, 55, 70, 85].sort(() => 0.5 - Math.random());

    this.currentAnswers.forEach((txt, index) => {
      const d = document.createElement("div");
      d.className = "falling-answer";
      d.style.left = `${positions[index]}%`;
      d.style.animationDelay = `${Math.random() * 3}s`;
      d.textContent = txt;
      this.gameArea.appendChild(d);
      this.answers.push(d);
    });
  }

  loop() {
    this.updateBullets();
    this.checkCollisions();
    this.animationFrameId = requestAnimationFrame(() => this.loop());
  }

  updateBullets() {
    this.bullets.forEach((b, i) => {
      let currentBottom = parseFloat(b.style.bottom);
      b.style.bottom = currentBottom + 10 + "px";
      if (currentBottom > this.gameArea.offsetHeight) {
        b.remove();
        this.bullets.splice(i, 1);
      }
    });
  }

  checkCollisions() {
    for (let i = this.bullets.length - 1; i >= 0; i--) {
      for (let j = this.answers.length - 1; j >= 0; j--) {
        const bullet = this.bullets[i];
        const ans = this.answers[j];
        if (this.collide(bullet, ans)) {
          const isCorrect = ans.textContent === this.currentCorrectAnswer;
          this.resetAnimation();
          
          if (isCorrect) {
            this.controller.notifyCorrectAnswer();
          } else {
            this.controller.notifyWrongAnswer({ a: this.currentCorrectAnswer });
          }
          return;
        }
      }
    }
  }

  collide(a, b) {
    const r1 = a.getBoundingClientRect();
    const r2 = b.getBoundingClientRect();
    return !(
      r1.right < r2.left ||
      r1.left > r2.right ||
      r1.bottom < r2.top ||
      r1.top > r2.bottom
    );
  }

  clearObjects() {
    this.answers.forEach(a => a.remove());
    this.bullets.forEach(b => b.remove());
    this.answers = [];
    this.bullets = [];
  }
}
</script>